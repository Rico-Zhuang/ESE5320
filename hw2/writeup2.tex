\documentclass[12pt]{article}

% Packages
\usepackage{amsmath, amssymb} % math symbols
\usepackage{enumitem}         % better control over lists
\usepackage{hyperref}         % clickable links
\usepackage{graphicx}

% Title Info
\title{ESE5320 Homework 2}
\author{Rico Zhuang}
\date{September 12, 2025}

\begin{document}

\maketitle

\section*{Answers}

\begin{enumerate}
    \item \textbf{Identify}
    \begin{enumerate}[label=\arabic*)]
        \item \textbf{Scale}: this function downscales an image(stored in a 1d array \text{"input"}) by only outputing every two pixel.
        \\\\ \textbf{Filter}: applies a convolution filter to the image; first horizontally, then vertically, using hard-coded coefficients. It takes the input image to produce a smoothed output image.
        \\\\ \textbf{Differentiate}: for each pixel, use the value of its left pixel and its up pixel to calculate an average, and output will be the difference between that pixel's value and the average.
        \\\\ \textbf{Compress}: This compresses the input array using Huffman coding, packing bits into the output array one byte at a time. It returns the total number of bytes written to the output.


    \end{enumerate}

    \item  \textbf{Measure}


        \begin{tabular}{|c|c|c|c|}
        \hline
        Functions & $T_{\text{measured\_avg}}$(ns) & \% of Total Latency & $T_{\text{measured\_avg}}$(cycles) \\
        \hline
        Scale & 2.09032e+07 & 3.64 & 7.10708+e07\\
        \hline
        Filter horizontal & 1.03589e+08 & 14.57 & 3.52202e+08\\
        \hline
        Filter vertical & 1.04882e+08 & 16.39 & 3.56599e+08\\
        \hline
        Differentiate & 2.59741e+07 & 3.64 & 8.83120e+07\\
        \hline
        Compress & 3.22591e+08 & 61.94 & 1.09681e+09\\
        \hline

        \end{tabular}
        \begin{enumerate}[label=\arabic*)]
        \item Done
        \item Done
        \item Done

% \includegraphics[width=0.6\textwidth]{image5.png}
    \end{enumerate}

    \item \textbf{Analyze}
    \begin{enumerate}[label=\arabic*)]
        \item \begin{tabular}{|c|c|c|}
\hline
Functions & $T_{\text{measured\_avg}}$ (ns) & $T_{\text{measured\_avg}}$ (cycles @ 1.2\,GHz) \\
\hline
Scale             & 8.426840e+08 & 1.011221e+09 \\
\hline
Filter\_horizontal & 5.241310e+09 & 6.289572e+09 \\
\hline
Filter\_vertical   & 5.299610e+09 & 6.359532e+09 \\
\hline
Differentiate      & 1.632450e+09 & 1.958940e+09 \\
\hline
Compress           & 5.363130e+09 & 6.435756e+09 \\
\hline
\end{tabular}
    \item The Scale funtion has the highest latency.
    \item \includegraphics[width=1.0\textwidth]{3_3.png}
    \item total operation count is \textbf{3.35664e+08}, and average latency is \textbf{3.35664e+08} cycles
    \item I would choose \textbf{Compress} because it has the highest latency and therefore will benifit the most from speedups.
    \item function Compress takes about 29\% of total latency, so the maximum possible speedup is 1/(1-0.29) = \textbf{1.4}
    \item Done
    \item critical path length is \textbf{5 operations}
    \item need two cycles for mult, 3 for add and 1 for shift, therefore lower bound is \textbf{3 cycles}

    \end{enumerate}

    \item \textbf{Refine}
    \begin{enumerate}[label=\arabic*)]
        \item 6.289572e+09 cycles
        \item \begin{tabular}{|l|p{6cm}|p{3cm}|}
\hline
\textbf{Assembly} & \textbf{Annotation} & \textbf{Number of Executions $N$} \\
\hline
add x6, x7, x12 & LOOP1 index++ &  4000\\
\hline
mov x4, x9 & store input size & 4000 \\
\hline
mov x0, 0 & LOOP2 index++& 23976000 \\
\hline
mov w1, 0 & sum = 0 & 23976000 \\
\hline
ldrb    w3, [x4, x0]  & load Input byte & 167832000 \\
\hline
ldr w2, [x5, x0, lsl 2]  & load Coefficients\text{[i]}& 167832000 \\
\hline
add x0, x0, 1 & i++ & 167832000 \\
\hline
madd    w1, w3, w2, w1  & fused mult and add & 167832000\\
\hline
bne .L4 & branch back LOOP3 & 167832000 \\
\hline
lsr w1, w1, 8   & shift by 8 & 23976000 \\
\hline
strb w1, [x6], 1 & store to output, then ++ output pointer for next one& 23976000 \\
\hline
add x4, x4, 1 & X++ & 23976000 \\
\hline
cmp x7, x6 & LOOP2 condition check & 23976000 \\
\hline
bne .L7 & branch back LOOP2 & 23976000 \\
\hline
add x7, x7, x10 & ++ to output pointer & 4000\\
\hline
add x9, x9, x11 & ++ to input pointer & 4000 \\
\hline
cmp x7, x8 & LOOP1 condition check & 4000 \\
\hline
bne .L3 & branch back LOOP1 & 4000 \\
\hline


\end{tabular}

        \item madd    w1, w3, w2, w1 is the computation command
        \item Done
        \item $N_{\text{instr}} = 1174848000$
        \item \noindent $N_{\text{mem}} = 3.59640\times10^{8}$\\
\noindent $N_{\text{non\_mem}} = 8.15208\times10^{8}$\\
\noindent $T_{\text{filter\_h\_measured}} = 6.289572\times10^{9}\ \text{cycles}$\\
\noindent $T_{\text{cycle\_mem}} \approx 1.63552\times10^{1}\ \text{cycles}$


        \item $N_{\text{slow\_mem}} = 47976007$ \\
                $N_{\text{fast\_mem}} = 311663993$
        \item \noindent $T_{\text{filter\_h\_measured}}=\dfrac{N_{\text{non\_mem}}}{2}+N_{\text{fast\_mem}}+N_{\text{slow\_mem}}\,T_{\text{cycle\_slow\_mem}}$\\
\noindent $T_{\text{cycle\_slow\_mem}}\approx 1.16106\times10^{2}\ \text{cycles}$

    \end{enumerate}

    \item \textbf{Coding}
    \begin{enumerate}[label=\arabic*)]
        \item Done
        \item Done
        \item cdc naive: 1711894ns, cdc rolling: 39424ns. The new function takes 97\% less time

    \end{enumerate}

\end{enumerate}

\end{document}
